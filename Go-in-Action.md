# ch3 打包和工具链

## 包

定义：一组功能清晰的、小的代码代码单元，可包含多个文件，这些文件需要放在同一个目录下。



## 导入

远程导入：从远程仓库导入包

命令导入：给导入的包重名命

空白标识符`_` ：可加在未使用的导入包前，避免编译错误

`init` 函数：导入包后进行初始化



## Go工具链

`go env` 查看Go环境信息

`go doc` 查看API文档

- `go doc <package>` 在终端直接查看帮助文档
- `go doc -http=:6060 &` 在后台运行web服务器，可通过浏览器访问

可通过该命令来给自己的代码生成文档，若要对包进行说明，则可在`doc.go`下写

`go get` 获取依赖包

# ch4 数组、切片和映射

补充点：

1. 数组和切片申明的小区别

    ```go
    // 创建长度为2的数组
    a := [...]int{1, 2}
    // 创建长度为2的切片
    b := []int{1, 2}
    ```

2. 第三个索引的使用

   `slice[i:j:k]` 表示长度为 j - i, 容量为 k - i

   可以令j等于k，新创建一个切片，然后再append，达到与原切片脱离开来的目的

   ```go
   source := []string{"Apple", "Orange", "Plum", "Banana", "Grape"}
   slice := source[2:3:3]
   slice = append(slice, "Kiwi")
   ```

3. 切片可以`append`到另一个切片

   ```go
   // 创建两个切片,并分别用两个整数进行初始化
   s1 := []int{1, 2}
   s2 := []int{3, 4}
   // 将两个切片追加在一起,并显示结果
   fmt.Printf("%v\n", append(s1, s2...))
   ```

4. 使用`range`遍历切片时，创建了每个元素的副本，而不是直接返回对该元素的引用

5. 多维切片中的切片长度可以是不一样的

   ```go
   // 创建一个整型切片的切片
   slice := [][]int{{10}, {100, 200}}
   // 为第一个切片追加值为 20 的元素
   slice[0] = append(slice[0], 20)
   ```

6. 在64位架构的机器上，一个切片需要24字节的内存，即指针，长度和容量。
